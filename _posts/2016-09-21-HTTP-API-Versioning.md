---
layout: post
title: Версионирование HTTP API
published: true
---
#Версионирование HTTP API

## Service - эволюционирует, API - версионируется.
 
Не секрет, что активно используемые программные продукты должны постоянно развиваться и адаптироваться для того чтобы удволтеворять нуждам клиентов. К сожалению невсегда можно построить API который изначально будет достаточно гибким для того чтобы одновременно предоставлять новый функционал и при этом не нарушать контракт с существующими клиентами. Обычным подходом являетсе создание одновременно существующих нескольких версий API  таким образом чтобы существующие клиенты могли продолжать работать и в то же время новые клиенты могли получить доступ к новому функционалу. Однако нет никаких стандартов описывающих универсальный подход практической реализации. Зачастую при разработке API мало задумываются о версионировании и если  задумываются то не углубляются в варианты решения проблемы и выбирают первый вариант предложенный любимой поисковой системой. 
	Данная стастья описывает возможных вариантах которые могут быть использованы для обеспечения версионности API. Рассматривает существующие подходы их достоинства и недостатки. В данной статье речь идёт исключительно о API реализуемые поверх протокла HTTP. Давайте сразу обусловимся что мы рассматриваем реальный Business case с обеспечением высокой доступности.
    

Процесс версионирования API должен удволетворять следующим требованиям: 

Для начала коротко опишем суть проблемы: дело в том что как гворил шекспир "Ничто не вечно под луной" и все меняется. Модель \ бизнес может имезниться однако не все способны быстро перейти на исопльзование новой версии и вам приходиться одновременно поддерживать несолкьо версий вашего ФPI. 

 

Задачи: 
Рассмотрим варианты и пути решения.

Изолированность - выход новой версии API не должен затрагивать существующие версии.
Скорость - определние к какой версии API хочет обратиться клиент должно быть максимально быстро. 
Наглядность - клиенту должно быть максимально легко и понятно к какой версии API он хочет обратиться. 


Content Based - эта группа подходов основывается на определни версии API по средствам указания версии внутри HTTP пакета. Естественно что для определения куда же направить траффик необходимо задать правила например по средствам Regex шаблона. Следует отметить что чем дальше прячем тем больше времени и ресурсов необходимо серверу для определния цели. 

Для начала рассмотри проблему разработки. 

Один проет или разные разные проекты? 

Один проект - возможная сложность при развертовании, возможная сложность поддержки кода потмоу что могут содержать разные версии одной модели. 

Разнные проекты - легкость при разработки и возможная легкость при развертывании. 

Проблемы направления  

Варианты 

Content Based 

Url path segment  

HTTP GET: 

https://contoso.com/api/v1/foo 

Стоит отметить что этот вариант является наиболе распространеным. 

Основным недостатком является то что необходимо парсить TCP пакет. 

Так же часто отмечают что данный подход не сильно лоижться на RESTful по причине того что урл должен прдеставлять иселючительно ресурс и не его версию. 

Url query parameter 

HTTP GET: 

https://contoso.com/api/foo?version=1 

Header Get http://contos.com/api Api-Version: 2 

Content 
{ 
"Api-Version": 2 
} 


Не раюотает для HTTP GET 

Данный подход используется в JSON-RPC подобных реализациях. 

Крайне дорого с вычислительной точки зрения. 

Крайне сложно понять что куда потому что нужно распарсить все сообщение. 
Многие Tier 7 load balancers такие как Amazon / Azure и вовсе не поддерживают. 

Address Based - данный подход базируется на определнии целевого сервера на стадии DNS resolve.  

Address Based - решение заключается  в использовании префикса имени домена или он же называется сабдомен. 

Варианты 

http://v1.api.contos.com/ или http://v1api.contos.com/ 

Pros: 

Может быть исопльзовано не только для HTTP API 

Онсовным достоинством данного подхода является то, что процесс направления траффика переносится с инфратсруткруы на которой развернут API на DNS сревер и собственно не добавляет никакого overhead. 

Так же отлично можно использовать Tier 4 load balancers. 

Хоть данная статья и о HTTP API, следует отметить что данный подход можно использовать и с TCP based api. 

Cons: 

К минусам стоит отнести то, что для данного подхода потребуются манипуляции на DNS сервере. 

В случае использования TLS придется покупать более дорогой wildcard ssl certificate. 

Разница между подходами заключается в том что для того что бы направить траффик придется использовать Tier 7 Load Balancer - Балансироващик нагрузки который работает на уровне приложения. Т.е. для того что бы понять куда направлять траффик ему придется распарсить TCP сообщение как HTTP и по заданному шаблону определить соответсвующую версию API. 

При таком подоходе для направления траффика на нужную версиию можно использовать DNS based traffic management - распределения траффика на основании DNS. 

Вывод: очевидно самым универсальным решением будет являться использование раздельных версий апи с Layer 4 Load Balancer и DNS based traffic management. Однако ваше решение может естественно отличаться ввиду определенных причин и ограничений.

----
